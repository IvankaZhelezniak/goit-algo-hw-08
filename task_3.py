# Є декілька мережевих кабелів різної довжини, їх потрібно об'єднати по два за раз в один кабель, 
# використовуючи з'єднувачі, у порядку, який призведе до найменших витрат. 
# Витрати на з'єднання двох кабелів дорівнюють їхній сумі довжин, а загальні витрати дорівнюють сумі з'єднання всіх кабелів.

# Код знаходить порядок об'єднання мережевих кабелів різної довжини,
# який мінімізує загальні витрати і повертає мінімальну з можливих сум загальних витрат..

# Код виконується і повертає мінімальну з можливих сум загальних витрат.

import heapq
from typing import List, Tuple

def min_connect_cost(cables: List[int], return_plan: bool = False) -> int | Tuple[int, List[Tuple[int, int, int]]]:
    """
    Мінімізує сумарну вартість з'єднання кабелів попарно.
    Алгоритм (жадібний / як у Хаффмана):
      - завжди беремо 2 (два) найкоротші кабелі, з’єднуємо їх (вартість = сума довжин),
      - додаємо новий кабель назад у купу,
      - повторюємо, доки не лишиться один кабель.
    Це гарантує мінімальну можливу суму витрат.

    Параметри:
      cables: список довжин кабелів (невід’ємні числа).
      return_plan: якщо True — то повертає ще й детальний план з’єднань.

    Повертає:
      Якщо return_plan = False: лише мінімальну вартість (int).
      Якщо return_plan = True: (мінімальна_вартість, план), де
        план — список кортежів (a, b, cost), a і b — довжини з’єднаних кабелів, cost = a + b.

    Крайові випадки:
      - 0 або 1 кабель → витрати 0 (нічого з’єднувати).
    Складність: O(n log n) (через операції з купою).
    """
    n = len(cables)
    if n <= 1:
        return (0, []) if return_plan else 0

    # 1) Створюю мін-купу з довжин
    heap = list(cables)
    heapq.heapify(heap)

    total_cost = 0
    plan: List[Tuple[int, int, int]] = []

    # 2) Поки в купі більше ніж 1 елемент — дістаю 2 найменші та з’єдную
    while len(heap) > 1:
        a = heapq.heappop(heap)  # найкоротший
        b = heapq.heappop(heap)  # другий за короткістю
        cost = a + b
        total_cost += cost
        # новий з’єднаний кабель повертаю в купу
        heapq.heappush(heap, cost)
        if return_plan:
            plan.append((a, b, cost))

    return (total_cost, plan) if return_plan else total_cost



#  швидкі тести

if __name__ == "__main__":
    # Приклад 1
    cables = [8, 4, 6, 12]
    # Оптимальний порядок дає суму 58:
    # 4+6=10, heap=[8,10,12]
    # 8+10=18, heap=[12,18]
    # 12+18=30, heap=[30]
    # total = 10+18+30 = 58
    cost, plan = min_connect_cost(cables, return_plan=True)
    print("Кабелі:", cables)
    print("Мінімальна вартість:", cost)      # очікуємо 58
    print("План з’єднань (a, b, cost):")
    for step in plan:
        print("  ", step)

    # Приклад 2 (ще один набір)
    assert min_connect_cost([1, 2, 3, 4, 5]) == 33
    # Пояснення однієї з оптимальних послідовностей:
    # (1+2)=3 -> [3,3,4,5]
    # (3+3)=6 -> [4,5,6]
    # (4+5)=9 -> [6,9]
    # (6+9)=15 -> []   total = 3+6+9+15 = 33

    # Крайові випадки
    assert min_connect_cost([]) == 0
    assert min_connect_cost([7]) == 0
    assert min_connect_cost([5, 5]) == 10

    print("Всі тести пройдені!")
